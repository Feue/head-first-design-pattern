## 1 OO原则

1. 封装变化。
2. 多用组合，少用继承。
3. 针对接口编程，不针对实现编程。
4. 为交互对象之间的松耦合设计而努力。
5. 类应该对扩展开放，对修改关闭(开闭原则)。
6. 要依赖抽象，不要依赖具体类。
7. 最少知识原则：只和你的密友谈话。
    在设计一个系统时，不管是任何对象，都需要注意它所交互的类有哪些，并注意它和这些类是如何交互的。
8. 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。
8. 单一责任：一个类应该只有一个引起变化的原因。

## 2 策略模式

**策略模式**定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## 3 观察者模式

在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。

代表：MVC

Subject(主题) --> Observer(观察者)

主题数据改变，通知观察者。

Java内置观察者模式(`java.util`包下)：Observable(可观察者)、Observer(观察者)。主题继承Observable类，观察者实现Observer接口。

## 4 装饰器模式

——动态地将责任附加到对象上。想要扩展功能，装饰着提供有别于继承的另一种选择。

代码应该如同晚霞中的莲花一样地关闭（免于改变），如同晨曦中的莲花一样地开放（能够扩展）。
类应该对扩展开放，对修改关闭。

装饰者该做的事，就是增加行为到被包装对象上。当需要窥视装饰者链中的每一个装饰者时，这就超出他们的天赋了。

![img.png](https://gitee.com/feng_junjie/imgs/raw/master/img.png)

![img_1.png](https://gitee.com/feng_junjie/imgs/raw/master/img_1.png)

## 5 工厂模式

**简单工厂**其实不是一个设计模式，反而比较像是一种编程习惯。

工厂类 / 工厂方法

所有工厂模式都用来封装对象的创建。

工厂方法模式(Factory Method Pattern)通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

**抽象工厂模式**提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

创建者类(Creator): 定义一个抽象的工厂方法，让子类实现此方法制造产品。

产品类: 具体的产品

![img.png](https://gitee.com/feng_junjie/imgs/raw/master/202109231729918.png)

![image-20210923173004872](https://gitee.com/feng_junjie/imgs/raw/master/202109231730086.png)

## 6 单例模式 （独一无二的对象）

**单例模式**确保一个类只有一个实例，并提供一个全局的访问点。

有一些对象我们只需要**一个**：线程池(Thread Pool)、缓存(cache)、对话框、处理偏好设置和注册表(registry)的对象、日志对象，充当打印机、显卡等设备的驱动程序的对象。事实上，这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，如：程序的行为异常、资源使用过量，或者是不一致的结果。

![image-20211012172635345](https://gitee.com/feng_junjie/imgs/raw/master/202110121726558.png)

### 经典的单例模式（懒汉式，线程不安全）

```java
package com.feue.DesignPattern.SingletonPattern;
/**
 * @author Feue
 * @create 2021-10-12 17:16
 *
 * 经典的单例模式
 */
public class ClassicSingleton {
    // 利用一个静态变量来记录 ClassicSingleton 类的唯一实例
    private static ClassicSingleton uniqueInstance;
    // 构造器声明为私有，只有自己类内才可以调用
    private ClassicSingleton() {}
    // 实例化对象，并返回这个实例
    public static ClassicSingleton getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new ClassicSingleton();
        }
        return uniqueInstance;
    }
}
```

> **注：** 这个版本是线程不安全的：

```Java
public static void main(String[] args) {
    for (int i = 0; i < 5; i++) {
        new Thread(() -> {
            System.out.println(ClassicSingleton.getInstance());
        }).start();
    }
}
```

![image-20211012174208168](https://gitee.com/feng_junjie/imgs/raw/master/202110121742311.png)

### 饿汉式（线程安全）

依赖 **JVM** 在加载这个类时马上创建此唯一的实例。**JVM** 保证在任何线程访问 instance 静态变量之前，一定先创建此实例。

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

### 双重锁校验（线程安全）

利用双重检查加锁，首先检查是否已经实例化过，若尚未实例化，**才**进行同步。这样一来，只有第一次会同步。

```java
public class Singleton {
    private volatile static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

## 7 命令模式（封装调用）

将“动作的请求者”从“动作的执行者”对象中解耦。利用“命令对象”，把请求封装成一个特定对象。

> **命令模式**将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

### 类图

![image-20211013144046498](https://gitee.com/feng_junjie/imgs/raw/master/202110131440894.png)

### 示例

![image-20211013163814359](https://gitee.com/feng_junjie/imgs/raw/master/202110131638566.png)

```java
public interface Command {
    void execute();
}
```

#### 实现遥控器

```java
public class RemoteControl {
    Command[] onCommands;
    Command[] offCommands;

    public RemoteControl() {
        onCommands = new Command[7];
        offCommands = new Command[7];
        Command noCommand = new noCommand();
        for (int i = 0; i < 7; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }
    public void setCommand(int slot, Command onCommand, Command offCommand) {
        // setCommand() 方法必须有3个参数，分别是插槽位置、开命令、关命令
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }
    // 当按下开或关的按钮，硬件就会负责调用对应的方法
    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }
    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("\n----- Remote Control -----\n");
        for (int i = 0; i < 7; i++) {
            sb.append("[slot "+i+"]"+onCommands[i].getClass().getName()+"    "+
                offCommands[i].getClass().getName()+"\n");
        }
        return sb.toString();
    }
}
```

#### 实现命令

```java
public class RemoteLoader {
    public static void main(String[] args) {
        RemoteControl remoteControl = new RemoteControl();
        // 创建所有的灯装置
        Light livingRoomLight = new Light("Living Room");
        Light kitchenLight = new Light("Kitchen");
        // 创建所有的灯命令对象
        LightOnCommand livingRoomLightOn = new LightOnCommand(livingRoomLight);
        LightOffCommand livingRoomLightOff = new LightOffCommand(livingRoomLight);
        LightOnCommand kitchenLightOn = new LightOnCommand(kitchenLight);
        LightOffCommand kitchenLightOff = new LightOffCommand(kitchenLight);
        // 将命令对象挂载到插槽中
        remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);
        remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);
		// 打印每个插槽和它被指定的命令
        System.out.println(remoteControl);
		// 按下开与关的按钮
        remoteControl.onButtonWasPushed(0);
        remoteControl.offButtonWasPushed(0);
        remoteControl.onButtonWasPushed(1);
        remoteControl.offButtonWasPushed(1);
    }
}
```

![image-20211013163153276](https://gitee.com/feng_junjie/imgs/raw/master/202110131631386.png)

#### NoCommand

```java
public class noCommand implements Command {
    @Override
    public void execute() {
    }
}
```

将每个插槽都预先指定成 NoCommand 对象，以便确定每个插槽永远都有命令对象。

> NoCommand 对象是一个空对象(null object)，当不想返回一个有意义的对象时，空对象就很有用。也可以将处理 null 的责任转移给空对象。

### 撤销操作

使用栈记录指令的调用，撤销时执行和栈顶相反的指令。

### 应用：

**队列请求**

命令可以将运算块打包（一个接收者和一组动作），然后将它传来传去，就像是一般的对象一样。现在，即使再命令对象创建许久之后，运算依然可以被调用。

**日志请求**

执行命令时，将历史记录储存在磁盘中，一旦系统死机，就可以将命令对象重新加载，并成批地依次调用这些对象的 execute() 方法。

## 8 适配器与外观模式（随遇而安）

> **适配器模式**将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

这个模式可以通过创建适配器进行接口转换，让不兼容的接口变成兼容。这可以让客户从实现的接口解耦。如果在一段时间之后，我们想要改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。

### 对象适配器

![image-20211026150700321](https://gitee.com/feng_junjie/imgs/raw/master/202110261507498.png)

```java
// 鸭子接口
public interface Duck {
    public void quack();
    public void fly();
}
// 鸭子的具体实现类
public class MallardDuck implements Duck {
    @Override
    public void quack() {
        System.out.println("Quack");
    }
    @Override
    public void fly() {
        System.out.println("I'm flying");
    }
}
```

```java
// 火鸡接口
public interface Turkey {
    // 火鸡不会呱呱叫，只会咯咯(gobble)叫。
    public void gobble();
    // 火鸡会飞，但飞不远。
    public void fly();
}
// 火鸡的具体实现类
public class WildTurkey implements Turkey{
    @Override
    public void gobble() {
        System.out.println("Gobble gobble");
    }
    @Override
    public void fly() {
        System.out.println("I'm flying a short distance");
    }
}
```

```java
// 火鸡适配器，将火鸡伪装成鸭子
// 首先，需要实现想转换成的类型接口，也就是客户希望看到的接口。
public class TurkeyAdapter implements Duck {
    Turkey turkey;
    // 接着，需要取得要适配的对象引用
    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }
    // 然后实现接口中的所有方法
    @Override
    public void quack() {
        turkey.gobble();
    }
    // 火鸡飞行距离短，要让火鸡和鸭子的飞行距离对应，需要连续调用5次火鸡的fly()
    @Override
    public void fly() {
        for (int i = 0; i < 5; i++) {
            turkey.fly();
        }
    }
}
```

```java
// 测试类
public class DuckTestDrive {
    public static void main(String[] args) {
        // 创建一只鸭子
        MallardDuck duck = new MallardDuck();
        // 创建一只火鸡
        WildTurkey turkey = new WildTurkey();
        // 将火鸡包装进适配器，使它看起来像是一只鸭子。
        Duck turkeyAdapter = new TurkeyAdapter(turkey);
        // 测试火鸡
        System.out.println("The Turkey says...");
        turkey.gobble();
        turkey.fly();
        // 使用testDuck()测试鸭子
        System.out.println("\nThe Duck says...");
        testDuck(duck);
        // 使用testDuck()测试火鸡假扮的鸭子
        System.out.println("\nThe TurkeyAdapter says...");
        testDuck(turkeyAdapter);
    }
    public static void testDuck(Duck duck) {
        duck.quack();
        duck.fly();
    }
}
```

<img src='https://gitee.com/feng_junjie/imgs/raw/master/202110261502781.png' align='left'>

### 类适配器

**类适配器**需要多继承才能够实现，这在Java中是不可能的。但是当使用多继承语言的时候，还是可能遇到这样的需求。

**类图：**

![image-20211026173132870](https://gitee.com/feng_junjie/imgs/raw/master/202110261731014.png)

> 对象适配器和类适配器使用两种不同的适配方法，分别是组合和继承。
>
> 由于使用组合，对象适配器不仅可以适配某个类，也可以适配该类的子类。

### 外观模式（简化接口）

> 它将一个或数个类的复杂的一切都隐藏在背后，只显露出一个干净美好的外观。
>
> **外观模式**提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

![image-20211027143126458](https://gitee.com/feng_junjie/imgs/raw/master/202110271431588.png)

![image-20211027134511543](https://gitee.com/feng_junjie/imgs/raw/master/202110271345815.png)

![image-20211027134549134](https://gitee.com/feng_junjie/imgs/raw/master/202110271345483.png)

1. 外观没有“封装”子系统的类，外观只提供简化的接口。客户有需要依然可以直接使用子系统的类。
2. 可以为一个子系统创建许多个外观。
3. 外观不只是简化了接口，也将客户从组件的子系统中解耦。

**家庭影院外观：**

```java
public class HomeTheaterFacade {
    // 将会用到的子系统组件组合在外观中
    Amplifier amp;
    Tuner tuner;
    DvdPlayer dvd;
    CdPlayer cd;
    Projector projector;
    TheaterLights lights;
    Screen screen;
    PopcornPopper popper;
    // 外观将子系统中每一个组件的引用都传入它的构造器中。
    // 然后外观把它们赋值给相应的实例变量。
    public HomeTheaterFacade(Amplifier amp,
                             Tuner tuner,
                             DvdPlayer dvd,
                             CdPlayer cd,
                             Projector projector,
                             TheaterLights lights,
                             Screen screen,
                             PopcornPopper popper) {
        this.amp = amp;
        this.tuner = tuner;
        this.dvd = dvd;
        this.cd = cd;
        this.projector = projector;
        this.lights = lights;
        this.screen = screen;
        this.popper = popper;
    }
    // watchMovie()将之前手动进行的每项任务依次处理。
    // 每项任务都是委托子系统中相应的组件处理。
    public void watchMovie(String movie) {
        System.out.println("Get ready to watch a movie...");
        popper.on();
        popper.pop();
        lights.dim(10);
        screen.down();
        projector.on();
        projector.wideScreenMode();
        amp.on();
        amp.setDvd(dvd);
        amp.setSurroundSound();
        amp.setVolume(5);
        dvd.on();
        dvd.play(movie);
        System.out.println();
    }
    // endMovie()负责关闭一切。
    public void endMovie() {
        System.out.println("Shutting movie theater down...");
        popper.off();
        lights.on();
        screen.up();
        projector.off();
        amp.off();
        dvd.stop();
        dvd.eject();
        dvd.off();
    }
}
```

**测试类：**

```java
public class HomeTheaterTestDrive {
    public static void main(String[] args) {
        // 实例化组件
        Amplifier amp = new Amplifier();
        Tuner tuner = new Tuner(amp);
        DvdPlayer dvd = new DvdPlayer(amp);
        CdPlayer cd = new CdPlayer(amp);
        Projector projector = new Projector(dvd);
        TheaterLights lights = new TheaterLights();
        Screen screen = new Screen();
        PopcornPopper popper = new PopcornPopper();
		// 实例化外观
        HomeTheaterFacade homeTheater =
                new HomeTheaterFacade(amp, tuner, dvd, cd, projector, lights, screen, popper);
		// 测试外观
        homeTheater.watchMovie("Raiders of the Lost Ark");
        homeTheater.endMovie();
    }
}
```

## 9 模板方法模式（封装算法）

> **模板方法模式**在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

### 未使用模板方法

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 16:29
 * 咖啡类用来煮咖啡。
 */
public class Coffee {

    /* 咖啡冲泡法 */
    void prepareRecipe() {
        boilWater();
        brewCoffeeGrinds();
        pourInCup();
        addSugarAndMilk();
    }
    /* 下面四个方法，每个方法都实现了算法中的每一个步骤：煮沸水、冲泡咖啡、把咖啡倒进杯子、加糖和奶 */
    public void boilWater() {
        System.out.println("Boiling water");
    }

    public void brewCoffeeGrinds() {
        System.out.println("Dripping Coffee through filter");
    }

    public void pourInCup() {
        System.out.println("Pouring into cup");
    }
    public void addSugarAndMilk() {
        System.out.println("Adding Sugar and Milk");
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 16:36
 * 茶类用来泡茶
 */
public class Tea {
    /* 与咖啡的实现很像，其中第2和第4个步骤不一样，但基本上是相同的冲泡方法 */
    void prepareRecipe() {
        boilWater();
        steepTeaBag();
        pourInCup();
        addLemon();
    }
    /* 下面四个方法，每个方法都实现了算法中的每一个步骤：煮沸水、冲泡茶叶、把茶倒进杯子、加柠檬。
    * boilWater()、pourIntoCup()这两个方法和咖啡的方法完全一样，出现了重复的代码。
    * steepTeaBag()、addLemon()是泡茶专有的。 */
    public void boilWater() {
        System.out.println("Boiling water");
    }

    public void steepTeaBag() {
        System.out.println("Steeping the tea");
    }

    public void pourInCup() {
        System.out.println("Pouring into cup");
    }
    public void addLemon() {
        System.out.println("Adding Lemon");
    }
}
```

### 使用模板方法

![image-20211207165653139](https://gitee.com/feng_junjie/imgs/raw/master/202112071656204.png)

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 17:00
 * 咖啡因饮料超类
 */
public abstract class CaffeineBeverage {
    /* 现在，用同一个prepareRecipe()方法来处理茶和咖啡。方法声明为final，不希望子类去覆盖这个方法。
    * 将第2和第4个步骤泛化为brew()和addCondiments()。 */
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    /* 因为咖啡和茶处理这些方法的做法不同，所以这两个方法必须声明为抽象的，由子类去实现。 */
    abstract void brew();
    abstract void addCondiments();

    void boilWater() {
        System.out.println("Boiling water");
    }

    void pourInCup() {
        System.out.println("Pouring into cup");
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 17:42
 */
public class Tea extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Steeping the tea");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding Lemon");
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 17:43
 */
public class Coffee extends CaffeineBeverage {
    @Override
    void brew() {
        System.out.println("Dripping Coffee through filter");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding Sugar and Milk");
    }
}
```

![image-20211207174637702](https://gitee.com/feng_junjie/imgs/raw/master/202112071746808.png)

**prepareRecipe()就是模板方法**，因为：

- 它是一个方法。
- 它用作一个算法的模板，在这个例子中，算法是用来制作咖啡因饮料的。

在这个模板中，算法内的每一个步骤都被一个方法代表了。

> 模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

![image-20211207175233272](https://gitee.com/feng_junjie/imgs/raw/master/202112071752365.png)

### 对模板方法进行“挂钩”

我们也可以有“默认不做事的方法”，我们称这种方法为“hook”（钩子）。子类可以视情况决定要不要覆盖它们。

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 18:02
 */
public abstract class CaffeineBeverageWithHook {
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    abstract void brew();

    abstract void addCondiments();

    void boilWater() {
        System.out.println("Boiling water");
    }

    void pourInCup() {
        System.out.println("Pouring into cup");
    }

    boolean customerWantsCondiments() {
        return true;
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @author Feue
 * @create 2021-12-07 18:04
 */
public class CoffeeWithHook extends CaffeineBeverageWithHook {
    @Override
    void brew() {
        System.out.println("Dripping Coffee through filter");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding Sugar and Milk");
    }

    @Override
    boolean customerWantsCondiments() {
        String answer = getUserInput();

        if (answer.toLowerCase().startsWith("y")) {
            return true;
        } else {
            return false;
        }
    }

    private String getUserInput() {
        String answer = null;
        System.out.print("Would you like milk and sugar with your coffee (y/n)? ");
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        try {
            answer = reader.readLine();
        } catch (IOException e) {
            System.err.println("IO error trying to read your answer");
        }
        if (answer == null) {
            return "no";
        }
        return answer;
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @author Feue
 * @create 2021-12-07 18:09
 */
public class TeaWithHook extends CaffeineBeverageWithHook {
    @Override
    void brew() {
        System.out.println("Steeping the tea");
    }

    @Override
    void addCondiments() {
        System.out.println("Adding Lemon");
    }

    @Override
    boolean customerWantsCondiments() {
        String answer = getUserInput();

        if (answer.toLowerCase().startsWith("y")) {
            return true;
        } else {
            return false;
        }
    }

    private String getUserInput() {
        String answer = null;
        System.out.print("Would you like lemon with your tea (y/n)? ");
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        try {
            answer = reader.readLine();
        } catch (IOException e) {
            System.err.println("IO error trying to read your answer");
        }
        if (answer == null) {
            return "no";
        }
        return answer;
    }
}
```

```java
package com.feue.DesignPattern.TemplateMethodPattern;

/**
 * @author Feue
 * @create 2021-12-07 18:11
 */
public class BeverageTestDrive {
    public static void main(String[] args) {
        TeaWithHook tea = new TeaWithHook();
        CoffeeWithHook coffee = new CoffeeWithHook();

        System.out.println("\nMaking tea...");
        tea.prepareRecipe();

        System.out.println("\nMaking coffee...");
        coffee.prepareRecipe();
    }
}
```

![image-20211207181452084](https://gitee.com/feng_junjie/imgs/raw/master/202112071814143.png)

### 好莱坞原则

> 别调用（打电话给）我们，我们会调用（打电话给）你。

好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖低层组件，而低层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖低层组件时，依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。

在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。

![image-20211208152646685](https://gitee.com/feng_junjie/imgs/raw/master/202112081526947.png)

![image-20211208155230256](https://gitee.com/feng_junjie/imgs/raw/master/202112081552419.png)

![image-20211208155302352](https://gitee.com/feng_junjie/imgs/raw/master/202112081553539.png)

## 10 迭代器与组合模式

### 迭代器模式

**迭代器模式**提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

#### 意义

- 如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码和这些聚合搭配，使用。
- 把在元素之间游走的责任交给迭代器，而不是聚合对象。不仅让聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面（管理对象集合），而不去理会遍历的事情。

![image-20211210165645710](https://gitee.com/feng_junjie/imgs/raw/master/202112101656883.png)

```java
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-10 17:04
 */
public interface Menu {
    Iterator<MenuItem> createIterator();
}
```

```java
/**
 * @author Feue
 * @create 2021-12-10 15:23
 */
public class MenuItem {
    String name;
    String description;
    boolean vegetarian;
    double price;

    public MenuItem(String name,
                    String description,
                    boolean vegetarian,
                    double price) {
        this.name = name;
        this.description = description;
        this.vegetarian = vegetarian;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public boolean isVegetarian() {
        return vegetarian;
    }

    public double getPrice() {
        return price;
    }
}
```

```java
import java.util.ArrayList;
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-10 15:32
 */
public class PancakeHouseMenu implements Menu {
     ArrayList<MenuItem> items;

    public PancakeHouseMenu() {
        this.items = new ArrayList<>();

        addItem("K&B's Pancake Breakfast",
                "Pancakes with scrambled eggs, and toast",
                true, 2.99);
        addItem("Regular Pancake Breakfast",
                "Pancakes with fried eggs, sausage",
                false, 2.99);
        addItem("Blueberry Pancakes",
                "Pancakes made with fresh blueberries",
                true, 3.49);
        addItem("Waffles",
                "Waffles, with your choice of blueberries or strawberries",
                true, 3.59);
    }

    public void addItem(String name, String description,
                        boolean vegetarian, double price) {
        MenuItem item = new MenuItem(name, description, vegetarian, price);
        items.add(item);
    }

    @Override
    public Iterator<MenuItem> createIterator() {
        return items.iterator();
    }
    // 还有很多其他方法
}
```

```java
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-10 15:45
 */
public class DinerMenu implements Menu {
    static final int MAX_ITEMS = 6;
    int numberOfItems = 0;
    MenuItem[] items;

    public DinerMenu() {
        items = new MenuItem[MAX_ITEMS];
        addItem("Vegetarian BLT",
                "(Faking') Bacon with lettuce & tomato on whole wheat",
                true, 2.99);
        addItem("BLT",
                "Bacon with lettuce & tomato on whole wheat",
                false, 2.99);
        addItem("Soup of the day",
                "Soup of the day, with a side of potato salad",
                false, 3.29);
        addItem("Hot dog",
                "A hot dog, with sauerkraut, relish, onions, topped with cheese",
                false, 3.05);
    }

    public void addItem(String name, String description,
                        boolean vegetarian, double price) {
        MenuItem item = new MenuItem(name, description, vegetarian, price);
        if (numberOfItems >= MAX_ITEMS) {
            System.out.println("Sorry, menu is full! Can't add item to menu");
        } else {
            items[numberOfItems++] = item;
        }
    }

    @Override
    public Iterator<MenuItem> createIterator() {
        return new DinerMenuIterator(items);
    }
    // 其他方法
}
```

```java
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-10 15:28
 */
public class DinerMenuIterator implements Iterator<MenuItem> {
    MenuItem[] items;
    int position = 0;

    public DinerMenuIterator(MenuItem[] items) {
        this.items = items;
    }

    @Override
    public boolean hasNext() {
        if (position >= items.length || items[position] == null) {
            return false;
        }
        return true;
    }

    @Override
    public MenuItem next() {
        return items[position++];
    }

    @Override
    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException
                    ("You can't remove an item util you've done at least one next()");
        }
        if (items[position-1] != null) {
            for (int i = position-1; i < items.length-1; i++) {
                items[i] = items[i+1];
            }
            items[items.length-1] = null;
        }
    }
}
```

```java
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-10 16:13
 */
public class Waitress {
    Menu pancakeHouseMenu;
    Menu dinerMenu;

    public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {
        this.pancakeHouseMenu = pancakeHouseMenu;
        this.dinerMenu = dinerMenu;
    }

    public void printMenu() {
        Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();
        Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();
        System.out.println("MENU\n----\nBREAKFAST");
        printMenu(pancakeIterator);
        System.out.println("\nLUNCH");
        printMenu(dinerIterator);
    }

    private void printMenu(Iterator<MenuItem> iterator) {
        while (iterator.hasNext()) {
            MenuItem item = iterator.next();
            System.out.print(item.getName()+", ");
            System.out.print(item.getPrice()+" -- ");
            System.out.println(item.getDescription());
        }
    }
    //其他方法
}
```

```java
/**
 * @author Feue
 * @create 2021-12-10 16:20
 */
public class MenuTestDrive {
    public static void main(String[] args) {
        PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
        DinerMenu dinerMenu = new DinerMenu();
        Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);
        waitress.printMenu();
    }
}
```

![image-20211210174611098](https://gitee.com/feng_junjie/imgs/raw/master/202112101746146.png)

### 组合模式

> **组合模式**允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户已一致的方式处理个别对象以及对象组合。

![image-20211213161653399](https://gitee.com/feng_junjie/imgs/raw/master/202112131616549.png)

### 组合迭代器

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-13 16:22
 *
 * 因为有些方法只对菜单项有意义，而有些则只对菜单有意义，
 * 默认实现是抛出UnsupportedOperationException异常。
 * 这样，如果菜单项或菜单不支持某个操作，它们就不需要做任何事情，
 * 直接继承默认实现就可以了。
 */
public abstract class MenuComponent {
    public void add(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }

    public void remove(MenuComponent menuComponent) {
        throw new UnsupportedOperationException();
    }

    public MenuComponent getChild(int i) {
        throw new UnsupportedOperationException();
    }

    public String getName() {
        throw new UnsupportedOperationException();
    }

    public String getDescription() {
        throw new UnsupportedOperationException();
    }

    public double getPrice() {
        throw new UnsupportedOperationException();
    }

    public boolean isVegetarian() {
        throw new UnsupportedOperationException();
    }

    public void print() {
        throw new UnsupportedOperationException();
    }

    public Iterator<MenuComponent> createIterator() {
        throw new UnsupportedOperationException();
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-13 16:34
 */
public class Menu extends MenuComponent {
    private ArrayList<MenuComponent> components = new ArrayList<>();
    private String name;
    private String description;

    public Menu(String name, String description) {
        this.name = name;
        this.description = description;
    }

    @Override
    public void add(MenuComponent menuComponent) {
        components.add(menuComponent);
    }

    @Override
    public void remove(MenuComponent menuComponent) {
        components.remove(menuComponent);
    }

    @Override
    public MenuComponent getChild(int i) {
        return components.get(i);
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public void print() {
        System.out.print("\n"+getName());
        System.out.println(", "+getDescription());
        System.out.println("___________________");

        Iterator<MenuComponent> iterator = components.iterator();
        while (iterator.hasNext()) {
            MenuComponent component = iterator.next();
            component.print();
        }
    }

    @Override
    public Iterator<MenuComponent> createIterator() {
        return new CompositeIterator(components.iterator());
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-13 16:28
 */
public class MenuItem extends MenuComponent {
    private String name;
    private String description;
    private boolean vegetarian;
    private double price;

    public MenuItem(String name,
                    String description,
                    boolean vegetarian,
                    double price) {
        this.name = name;
        this.description = description;
        this.vegetarian = vegetarian;
        this.price = price;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public String getDescription() {
        return description;
    }

    @Override
    public boolean isVegetarian() {
        return vegetarian;
    }

    @Override
    public double getPrice() {
        return price;
    }

    @Override
    public void print() {
        System.out.print("  "+getName());
        if (isVegetarian()) {
            System.out.print("(V)");
        }
        System.out.println(", "+getPrice());
        System.out.println("    -- "+getDescription());
    }

    @Override
    public Iterator<MenuComponent> createIterator() {
        return new NullIterator();
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.*;

/**
 * @author Feue
 * @create 2021-12-14 14:13
 */
public class CompositeIterator implements Iterator<MenuComponent> {
    private Deque<Iterator<MenuComponent>> stack = new ArrayDeque<>();

    public CompositeIterator(Iterator<MenuComponent> iterator) {
        stack.push(iterator);
    }

    @Override
    public boolean hasNext() {
        if (stack.isEmpty()) {
            return false;
        } else {
            Iterator<MenuComponent> iterator = stack.peek();
            if (!iterator.hasNext()) {
                stack.pop();
                return this.hasNext();
            } else {
                return true;
            }
        }
    }

    @Override
    public MenuComponent next() {
        if (this.hasNext()) {
            Iterator<MenuComponent> iterator = stack.peek();
            MenuComponent component = iterator.next();
            if (component instanceof Menu) {
                stack.push(component.createIterator());
            }
            return component;
        }
        return null;
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-14 14:31
 */
public class NullIterator implements Iterator<MenuComponent> {
    @Override
    public boolean hasNext() {
        return false;
    }

    @Override
    public MenuComponent next() {
        return null;
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

import java.util.Iterator;

/**
 * @author Feue
 * @create 2021-12-13 16:41
 */
public class Waitress {
    private MenuComponent allMenus;

    public Waitress(MenuComponent allMenus) {
        this.allMenus = allMenus;
    }

    public void printMenu() {
        allMenus.print();
    }

    public void printVegetarianMenu() {
        Iterator<MenuComponent> iterator = allMenus.createIterator();
        System.out.println("\nVEGETARIAN MENU\n----");
        while (iterator.hasNext()) {
            MenuComponent component = iterator.next();
            try {
                if (component.isVegetarian()) {
                    component.print();
                }
            } catch (UnsupportedOperationException ignored) {}
        }
    }
}
```

```java
package com.feue.DesignPattern.CompositePattern;

/**
 * @author Feue
 * @create 2021-12-13 16:43
 */
public class MenuTestDrive {
    public static void main(String[] args) {
        MenuComponent pancakeHouseMenu =
                new Menu("PANCAKE HOUSE MENU", "Breakfast");
        MenuComponent dinnerMenu =
                new Menu("DINNER MENU", "Lunch");
        MenuComponent cafeMenu =
                new Menu("CAFE MENU", "Dinner");
        MenuComponent dessertMenu =
                new Menu("DESSERT MENU", "Dessert of course!");

        MenuComponent allMenus = new Menu("ALL MENUS", "All menus combined");

        allMenus.add(pancakeHouseMenu);
        allMenus.add(dinnerMenu);
        allMenus.add(cafeMenu);

        dinnerMenu.add(new MenuItem(
                "Pasta",
                "Spaghetti with Marinara Sauce, and a slice of sourdough bread",
                true, 3.89
        ));
        dinnerMenu.add(dessertMenu);

        dessertMenu.add(new MenuItem(
                "Apple Pie",
                "Apple pie with a flaky crust, topped with vanilla ice cream",
                true, 1.59
        ));

        Waitress waitress = new Waitress(allMenus);
        waitress.printMenu();
        waitress.printVegetarianMenu();
    }
}
```

![image-20211214153200648](https://gitee.com/feng_junjie/imgs/raw/master/202112141532762.png)

![image-20211214153332696](https://gitee.com/feng_junjie/imgs/raw/master/202112141533838.png)

![image-20211214153351520](https://gitee.com/feng_junjie/imgs/raw/master/202112141533634.png)

## 11 状态模式

> 策略模式和状态模式是**双胞胎**，在出生时才分开。**策略模式**是围绕可以互换的算法来创建成功业务的。**状态模式**通过改变对象内部状态来帮助对象控制自己的行为。

**状态模式**允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

![image-20211215163805724](https://gitee.com/feng_junjie/imgs/raw/master/202112151642660.png)

### 糖果机

![image-20211215114344359](https://gitee.com/feng_junjie/imgs/raw/master/202112151532708.png)

### 未使用设计模式

```java
package com.feue.DesignPattern.StatePattern.normal;

/**
 * @author Feue
 * @create 2021-12-15 11:46
 */
public class GumballMachine {
    private final static int SOLD_OUT = 0;
    private final static int NO_QUARTER = 1;
    private final static int HAS_QUARTER = 2;
    private final static int SOLD = 3;

    private int state = SOLD_OUT;
    private int count;

    public GumballMachine(int count) {
        this.count = count;
        if (count > 0) {
            this.state = NO_QUARTER;
        }
    }

    public void insertQuarter() {
        if (this.state == SOLD_OUT) {
            System.out.println("You can't insert a quarter, the machine is sold out");
        } else if (this.state == NO_QUARTER) {
            this.state = HAS_QUARTER;
            System.out.println("You inserted a quarter");
        } else if (this.state == HAS_QUARTER) {
            System.out.println("You can't insert another quarter");
        } else if (this.state == SOLD) {
            System.out.println("Please wait, we're already giving you gumball");
        }
    }

    public void ejectQuarter() {
        if (this.state == SOLD_OUT || this.state == NO_QUARTER) {
            System.out.println("You can't eject, you haven't inserted a quarter yet");
        } else if (this.state == HAS_QUARTER) {
            System.out.println("Quarter returned");
            this.state = NO_QUARTER;
        } else if (this.state == SOLD) {
            System.out.println("Sorry, you already turned the crank");
        }
    }

    public void turnCrank() {
        if (this.state == SOLD_OUT) {
            System.out.println("You turned, but there are no gumballs");
        } else if (this.state == NO_QUARTER) {
            System.out.println("You turned, but there's no quarter");
        } else if (this.state == HAS_QUARTER) {
            System.out.println("You turned...");
            this.state = SOLD;
            dispense();
        } else if (this.state == SOLD) {
            System.out.println("Turning twice doesn't get you another gumball");
        }
    }

    public void dispense() {
        if (this.state == SOLD_OUT || this.state == HAS_QUARTER) {
            System.out.println("No gumball dispensed");
        } else if (this.state == NO_QUARTER) {
            System.out.println("You need to pay first");
        } else if (this.state == SOLD) {
            System.out.println("A gumball comes rolling out the slot");
            this.count--;
            if (this.count == 0) {
                System.out.println("Oops, out of gumballs!");
                this.state = SOLD_OUT;
            } else {
                this.state = NO_QUARTER;
            }
        }
    }

    @Override
    public String toString() {
        return "\nMighty Gumball, Inc.\n"
                +"Java-enabled Standing Gumball Model #2021\n"
                +"Inventory: 0 gumballs\n"
                +"Machine state is "+this.getState()+"\n";
    }

    private String getState() {
        switch (this.state) {
            case 0: return "SOLD_OUT";
            case 1: return "NO_QUARTER";
            case 2: return "HAS_QUARTER";
            case 3: return "SOLD";
            default: return "ILLEGAL_STATE";
        }
    }
}
```

```java
package com.feue.DesignPattern.StatePattern.normal;

/**
 * @author Feue
 * @create 2021-12-15 13:48
 */
public class GumballMachineTestDrive {
    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.ejectQuarter(); // 要求机器退钱
        gumballMachine.turnCrank();// 转动曲柄，应该拿不到糖果

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果
        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果
        gumballMachine.ejectQuarter(); // 要求机器退钱

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.insertQuarter(); // 投入一枚硬币，应该拒绝
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果
        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果
        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果

        System.out.println(gumballMachine); // 打印机器状态
    }
}
```

![image-20211215153610961](https://gitee.com/feng_junjie/imgs/raw/master/202112151536058.png)

如果需要新添加一种状态，则原代码的所有方法都需要修改，对代码的侵入性很高。

### 使用状态模式

1. 首先，定义一个一个State接口。在这个接口内，糖果机的每个动作都有一个对应的方法。
2. 然后，为机器中的每个状态实现状态类。这些类将负责在对应的状态下进行机器的行为。
3. 最后，摆脱旧的条件代码，取而代之的方式是，将动作委托到状态类。

![image-20211215154712465](https://gitee.com/feng_junjie/imgs/raw/master/202112151547710.png)

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 15:57
 */
public class GumballMachine {
    private State soldOutState;
    private State noQuarterState;
    private State hasQuarterState;
    private State soldState;
    private State winnerState;

    private State state = this.soldOutState;
    private int count = 0;

    public GumballMachine(int numberGumballs) {
        this.soldOutState = new SoldOutState(this);
        this.noQuarterState = new NoQuarterState(this);
        this.hasQuarterState = new HasQuarterState(this);
        this.soldState = new SoldState(this);
        this.winnerState = new WinnerState(this);
        this.count = numberGumballs;
        if (numberGumballs > 0) {
            this.state = this.noQuarterState;
        }
    }

    public void insertQuarter() {
        this.state.insertQuarter();
    }

    public void ejectQuarter() {
        this.state.ejectQuarter();
    }

    public void turnCrank() {
        this.state.turnCrank();
        this.state.dispense();
    }

    public void setState(State state) {
        this.state = state;
    }

    public void releaseBall() {
        System.out.println("A gumball comes rolling out the slot...");
        if (this.count != 0) {
            this.count--;
        }
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }

    public State getWinnerState() {
        return winnerState;
    }

    public int getCount() {
        return count;
    }

    @Override
    public String toString() {
        return "\nMighty Gumball, Inc.\n"
                +"Java-enabled Standing Gumball Model #2021\n"
                +"Inventory: 0 gumballs\n"
                +"Machine state is "+this.state+"\n";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 15:54
 */
public interface State {
    void insertQuarter();
    void ejectQuarter();
    void turnCrank();
    void dispense();
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 16:15
 */
public class SoldOutState implements State {
    private GumballMachine gumballMachine;

    public SoldOutState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("You can't insert a quarter, the gumballs are sold out");
    }

    @Override
    public void ejectQuarter() {
        System.out.println("You can't eject, you haven't inserted a quarter");
    }

    @Override
    public void turnCrank() {
        System.out.println("You turned, but there are no gumballs");
    }

    @Override
    public void dispense() {
        System.out.println("No gumball dispensed");
    }

    @Override
    public String toString() {
        return "SOLD_OUT";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 15:56
 */
public class NoQuarterState implements State {
    private GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("You inserted a quarter");
        this.gumballMachine.setState(this.gumballMachine.getHasQuarterState());
    }

    @Override
    public void ejectQuarter() {
        System.out.println("You haven't inserted a quarter");
    }

    @Override
    public void turnCrank() {
        System.out.println("You turned, but there's no quarter");
    }

    @Override
    public void dispense() {
        System.out.println("You need to pay first");
    }

    @Override
    public String toString() {
        return "NO_QUARTER";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

import java.util.Random;

/**
 * @author Feue
 * @create 2021-12-15 16:19
 */
public class HasQuarterState implements State {
    private GumballMachine gumballMachine;
    private Random random;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
        this.random = new Random(System.currentTimeMillis());
    }

    @Override
    public void insertQuarter() {
        System.out.println("You can't insert another quarter");
    }

    @Override
    public void ejectQuarter() {
        System.out.println("Quarter returned");
        this.gumballMachine.setState(this.gumballMachine.getNoQuarterState());
    }

    @Override
    public void turnCrank() {
        System.out.println("You turned...");
        int winner = this.random.nextInt(10);
        if (winner == 0 && gumballMachine.getCount() > 1) {
            this.gumballMachine.setState(this.gumballMachine.getWinnerState());
        } else {
            this.gumballMachine.setState(this.gumballMachine.getSoldState());
        }
    }

    @Override
    public void dispense() {
        System.out.println("No gumball dispensed");
    }

    @Override
    public String toString() {
        return "HAS_QUARTER";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 16:25
 */
public class SoldState implements State {
    private GumballMachine gumballMachine;

    public SoldState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("Please wait, we're already giving you a gumball");
    }

    @Override
    public void ejectQuarter() {
        System.out.println("Sorry, you already turned the crank");
    }

    @Override
    public void turnCrank() {
        System.out.println("Turning twice doesn't get you another gumball!");
    }

    @Override
    public void dispense() {
        this.gumballMachine.releaseBall();
        if (this.gumballMachine.getCount() > 0) {
            this.gumballMachine.setState(this.gumballMachine.getNoQuarterState());
        } else {
            System.out.println("Oops, out of gumballs!");
            this.gumballMachine.setState(this.gumballMachine.getSoldOutState());
        }
    }

    @Override
    public String toString() {
        return "SOLD";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 17:19
 */
public class WinnerState implements State {
    private GumballMachine gumballMachine;

    public WinnerState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void insertQuarter() {
        System.out.println("Please wait, we're already giving you a gumball");
    }

    @Override
    public void ejectQuarter() {
        System.out.println("Sorry, you already turned the crank");
    }

    @Override
    public void turnCrank() {
        System.out.println("Turning twice doesn't get you another gumball!");
    }

    @Override
    public void dispense() {
        System.out.println("YOU'RE A WINNER! You get tow gumballs for your quarter");
        this.gumballMachine.releaseBall();
        if (this.gumballMachine.getCount() == 0) {
            this.gumballMachine.setState(this.gumballMachine.getSoldOutState());
        } else {
            this.gumballMachine.releaseBall();
            if (this.gumballMachine.getCount() > 0) {
                this.gumballMachine.setState(this.gumballMachine.getNoQuarterState());
            } else {
                System.out.println("Oops, out of gumballs!");
                this.gumballMachine.setState(this.gumballMachine.getSoldOutState());
            }
        }
    }

    @Override
    public String toString() {
        return "WINNER";
    }
}
```

```java
package com.feue.DesignPattern.StatePattern;

/**
 * @author Feue
 * @create 2021-12-15 17:30
 */
public class GumballMachineTestDrive {
    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果

        System.out.println(gumballMachine); // 打印机器状态

        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果
        gumballMachine.insertQuarter(); // 投入一枚硬币
        gumballMachine.turnCrank(); // 转动曲柄，应该拿到糖果

        System.out.println(gumballMachine); // 打印机器状态
    }
}
```

![image-20211215175035173](https://gitee.com/feng_junjie/imgs/raw/master/202112151750282.png)

采用状态模式之后：

- 将每个状态的行为局部化到它自己的类中。
- 将容易产生问题的if语句删除，以便日后维护。
- 让每一个状态“对修改关闭”，让糖果机“对扩展开放”，因为可以加入新的状态类。

## 12 代理模式



## 13 复合模式



## 14 其他模式



